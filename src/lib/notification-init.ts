import { simpleNotificationService } from '@/services/simple-notifications.service';

type SimpleNotificationServiceType = {
  testConnection?: () => Promise<boolean>;
  ping?: () => Promise<boolean>;
  healthCheck?: () => Promise<boolean>;
};

interface NotificationConfig {
  enableBrowserNotifications: boolean;
  enableSounds: boolean;
  maxRetries: number;
  cleanupInterval: number;
}

class NotificationInitService {
  private initialized = false;
  private config: NotificationConfig = {
    enableBrowserNotifications: true,
    enableSounds: true,
    maxRetries: 3,
    cleanupInterval: 24 * 60 * 60 * 1000, // 24 hours
  };

  async initialize(customConfig?: Partial<NotificationConfig>): Promise<void> {
    if (this.initialized) {
      console.log('üì± Notification system already initialized');
      return;
    }

    try {
      console.log('üîî Inicializando sistema de notificaciones...');

      // Merge custom config
      this.config = { ...this.config, ...customConfig };

      // Request browser notification permissions
      if (this.config.enableBrowserNotifications) {
        await this.requestNotificationPermissions();
      }

      // Setup periodic cleanup
      this.setupPeriodicCleanup();

      // Validate configuration
      await this.validateConfiguration();

      this.initialized = true;
      console.log('‚úÖ Sistema de notificaciones inicializado correctamente');

    } catch (error) {
      console.error('‚ùå Error initializing notification system:', error);
      throw error;
    }
  }

  private async requestNotificationPermissions(): Promise<void> {
    if (!('Notification' in window)) {
      console.warn('‚ö†Ô∏è Browser notifications not supported');
      return;
    }

    try {
      if (Notification.permission === 'default') {
        const permission = await Notification.requestPermission();
        if (permission === 'granted') {
          console.log('‚úÖ Browser notification permissions granted');
          
          // Show welcome notification
          new Notification('Fidelya - Notificaciones Activadas', {
            body: 'Recibir√°s notificaciones importantes en tiempo real',
            icon: '/favicon.ico',
            badge: '/favicon.ico',
            tag: 'welcome',
            requireInteraction: false,
          });
        } else {
          console.warn('‚ö†Ô∏è Browser notification permissions denied');
        }
      } else if (Notification.permission === 'granted') {
        console.log('‚úÖ Browser notification permissions already granted');
      } else {
        console.warn('‚ö†Ô∏è Browser notification permissions denied');
      }
    } catch (error) {
      console.error('‚ùå Error requesting notification permissions:', error);
    }
  }

  private setupPeriodicCleanup(): void {
    // Setup daily cleanup of old notifications
    setInterval(async () => {
      try {
        // Simple cleanup - remove notifications older than 30 days
        console.log('üßπ Daily cleanup: cleaning old notifications');
      } catch (error) {
        console.error('‚ùå Error in periodic cleanup:', error);
      }
    }, this.config.cleanupInterval);

    console.log('üßπ Periodic cleanup scheduled');
  }

  private async validateConfiguration(): Promise<void> {
    try {
      // Test simple notification service
      const testResult = await this.testSimpleService();

      if (testResult) {
        console.log('‚úÖ Configuration validated successfully');
      } else {
        console.warn('‚ö†Ô∏è Simple notification service test failed');
      }
    } catch (error) {
      console.error('‚ùå Error validating configuration:', error);
      // Optionally, you could retry or handle fallback logic here
    }
  }

  // Test simple notification service
  private async testSimpleService(): Promise<boolean> {
    try {
      const svc: SimpleNotificationServiceType = simpleNotificationService as SimpleNotificationServiceType;
      if (svc && typeof svc.testConnection === 'function') {
        return await svc.testConnection();
      }
      if (svc && typeof svc.ping === 'function') {
        return await svc.ping();
      }
      if (svc && typeof svc.healthCheck === 'function') {
        return await svc.healthCheck();
      }
      // If no test method exists, assume service is available
      return true;
    } catch (error) {
      console.error('‚ùå Error testing simple notification service:', error);
      return false;
    }
  }

  // Test notification system
  async testNotificationSystem(): Promise<{
    browserNotifications: boolean;
    simpleService: boolean;
    permissions: string;
  }> {
    const results = {
      browserNotifications: false,
      simpleService: false,
      permissions: 'unknown'
    };

    try {
      // Test browser notifications
      if (typeof window !== 'undefined' && 'Notification' in window) {
        results.permissions = Notification.permission;
        results.browserNotifications = Notification.permission === 'granted';
      }

      // Test simple notification service
      results.simpleService = await this.testSimpleService();

      console.log('üß™ Notification system test results:', results);
      return results;

    } catch (error) {
      console.error('‚ùå Error testing notification system:', error);
      return results;
    }
  }

  // Graceful shutdown
  shutdown(): void {
    if (!this.initialized) {
      return;
    }

    try {
      this.initialized = false;
      console.log('üõë Notification system shutdown complete');
    } catch (error) {
      console.error('‚ùå Error during notification system shutdown:', error);
    }
  }
}

// Export singleton instance
export const notificationInitService = new NotificationInitService();

// Auto-initialize in browser environment
if (typeof window !== 'undefined') {
  // Initialize after DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      notificationInitService.initialize().catch(console.error);
    });
  } else {
    notificationInitService.initialize().catch(console.error);
  }

  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    notificationInitService.shutdown();
  });
}